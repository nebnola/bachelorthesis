"""Fit generalised Ornstein-Uhlenbeck processes so that their autocorrelation function approaches a given desired
function. The generalised process of dimension N is given by a N-dimensional vector λ and an NxN-matrix B.
Since only the product adjugate(B)*B matters, in general it can be assumed that B is an upper triagonal matrix.
In order to perform the fit, we need a real parameter vector, so we take the real and imaginary parts of all the entries
of λ and B and put them into a vector, resulting in a 2(N + N*(N+1)/2)-dimensional problem. We use
matrices_from_params() to convert from this parameter vector into λ and B"""
import json
from typing import Callable
import numpy as np
from scipy import optimize
import process


class FitResult(optimize.OptimizeResult):
    """A class to store the results of fits. Basically an extension of OptimizeResult to store some parameters"""

    def __init__(self, optimize_result=None, **kwargs):
        super().__init__()
        self.update(kwargs)
        if optimize_result is not None:
            self.update(dict(optimize_result))

    @classmethod
    def from_file(cls, filename):
        """Create a FitResult object from file with given filename

        Works for files which were generated by FitResult.save()
        reads the json and replaces lists with np.ndarrays"""
        with open(filename, 'r') as f:
            d = json.load(f)
            for key, val in d.items():
                if isinstance(val, list):
                    d[key] = np.asarray(val)
            return cls(**d)

    def save(self, filename):
        """Save FitResult object to file

        Converts np.ndarrays to lists and then saves the object as json"""
        d = dict(self)
        for key, val in d.items():
            if isinstance(val, np.ndarray):
                # convert np.ndarrays to list so they can be serialised
                d[key] = val.tolist()
        with open(filename, 'w') as f:
            json.dump(d, f)

    def fit_values(self, t=None):
        """For a given vector of time points t, return values of the fit

        If t is not given, use time points that were used in the fit"""
        if t is None:
            t = self.t
        fit_class = FIT_FUNS[self.fit_fun]
        return fit_class.function(self.x, t)

    def target_values(self, t=None):
        """For a given vector of time points t, return values of the target function

        If t is not given, use time points that were used in the fit"""
        if t is None:
            t = self.t
        target_fun = TARGET_FUNS[self.target_fun]
        return target_fun(t)

    def coeffs_exponents(self):
        """Get coefficients and exponents of the underlying sum of exponentials

        Fit functions boil down to the form sum_j G_j exp(-W_j*t)
        This function returns G_j, W_j
        """
        fit_class = FIT_FUNS[self.fit_fun]
        return fit_class.coeffs_exponents(self.x)

    def max_dev(self, T=None):
        """Calculate maximum deviation between target and fit

        :param T: maximum time which is taken into consideration. If not given, it is the same as during the fit"""
        if T is None:
            T = max(self.t)
        t = np.linspace(0, T, 500)
        vals = self.fit_values(t)
        target_vals = self.target_values(t)
        return np.max(np.abs(vals - target_vals))


class FitBase:
    """Base class for fits

    A subclass represents a function with parameters to be fitted"""

    name = None

    @classmethod
    def function(cls, param, t):
        """Evaluate the fit function with given parameters param at time points t
        Return an array of function values with the same length as t"""
        raise NotImplementedError()

    @classmethod
    def residuals(cls, param, t, target_vals):
        """Calculate the difference between the fit function at time points t and given values target_vals"""
        diff = cls.function(param, t) - target_vals
        return np.concatenate((diff.real, diff.imag))

    @staticmethod
    def default_params(dim):
        """Return default initial parameter vector for when nothing else is provided"""
        raise NotImplementedError()

    @staticmethod
    def coeffs_exponents(param):
        """Get coefficients and exponents of the underlying sum of exponentials

        Fit functions boil down to the form sum_j G_j exp(-W_j*t)
        For a given parameter vector param, this function returns G_j, W_j
        """
        raise NotImplementedError()

    @classmethod
    def do_fit(cls, target_fun: Callable, t: np.ndarray, dim: int, x0=None, **kwargs):
        """Perform fit"""
        if x0 is None:
            x0 = cls.default_params(dim)
        target_vals = target_fun(t)
        o = optimize.least_squares(cls.residuals, x0, kwargs=dict(target_vals=target_vals,
                                                                  t=t),
                                   **kwargs)
        f = FitResult(o,
                      x0=x0,
                      t=t,
                      dim=dim,
                      fit_fun=cls.name,
                      target_fun=target_fun.__name__)
        return f


class FitOU(FitBase):
    """Fit function has the form of an auotocorrelation function of a generalised Ornstein-Uhlenbeck process

    It has parameters λ (vector) and B (matrix) which are encoded into a single parameter vector using
    matrices_from_params() and params_from_matrices()"""

    name = "general-ou"

    @staticmethod
    def matrices_from_params(param):
        """Calculate the vector λ (shape (dim,)) and the matrix B (shape (dim,dim)) for a given parameter vector

        The parameter vector has length 2*(dim + dim*(dim+1)/2), where the first dim entries are the real part of the
        vector
        λ, the next dim*(dim+1)/2 entries are the real parts of the elements of the upper triangular matrix B and the
        imaginary parts follow in the same manner"""
        length = len(param)
        dim = int(-1.5 + np.sqrt(9 / 4 + length))
        if length != 2 * (dim + dim * (dim + 1) / 2):
            raise ValueError("Parameter vector has incorrect length")

        real = param[:int(length / 2)]
        imag = param[int(length // 2):]
        lambdas = real[:dim] + 1j * imag[:dim]
        Bentries = real[dim:] + 1j * imag[dim:]
        B = np.zeros((dim, dim), dtype=complex)
        B[np.triu_indices(dim)] = Bentries
        return np.asarray(lambdas), B

    @staticmethod
    def params_from_matrices(lambd, b):
        """inverse operation to matrices_from_params()"""
        dim = len(lambd)
        bentries = b[np.triu_indices(dim)]
        return np.concatenate([lambd.real, bentries.real, lambd.imag, bentries.imag])

    @staticmethod
    def default_params(dim):
        return np.ones(int(2 * (dim + dim * (dim + 1) / 2)))

    @staticmethod
    def random_x0(dim):
        """Randomly generate a suitable starting value for the parameter in the Ornstein-Uhlenbeck fit"""
        realpartlambda = np.random.uniform(0.1, 5, size=dim)
        otherentries = np.random.uniform(-5, 5, size=dim + dim * (dim + 1))
        return np.concatenate((realpartlambda, otherentries))

    @staticmethod
    def coeffs_exponents(param):
        lambdas, b = FitOU.matrices_from_params(param)
        return process.general_ou_coeff(lambdas, b), lambdas

    @classmethod
    def function(cls, param, t):
        """Autocorrelation function of a generalised Ornstein-Uhlenbeck processs

        Calculate the autocorrelation function based on a parameter vector as defined by matrices_from_params
        :param param: A parameter vector
        :param t: An array of time points
        :return: The autocorrelation function evaluated at the given time points"""
        lambdas, b = cls.matrices_from_params(param)
        return process.general_ou_autoc(lambdas, b, t)


class FitExp(FitBase):
    """Fit function is a sum of exponential functions with complex coefficients and exponents"""

    name = "exp"

    @staticmethod
    def default_params(dim):
        return np.ones(4 * dim)

    @classmethod
    def function(cls, param, t):
        dim = int(len(param) / 4)
        exponents = param[:dim] + 1j * param[2 * dim:3 * dim]
        coeffs = param[dim:2 * dim] + 1j * param[3 * dim:]

        coeffsv, tv = np.meshgrid(coeffs, t)
        exponentsv, tv = np.meshgrid(exponents, t)
        return np.sum(coeffsv * np.exp(-exponentsv * tv), axis=1)


class FitExpPos(FitBase):
    """Fit function is a positive sum of exponential functions
    The parameter vector has 3*dim dimensions, first the real parts and the
    imaginary parts of the exponents, then the square root of the coefficients"""

    name = "exp-pos"

    @staticmethod
    def default_params(dim):
        return np.ones(3 * dim)

    @staticmethod
    def random_x0(dim):
        """Generate random suitable starting parameters for fitting positive sum of exponential functions"""
        realpartlambda = np.random.uniform(0.1, 5, size=dim)
        coefficients = np.random.uniform(0.1, 2, size=dim)
        imagpartlambda = np.random.uniform(-5, 5, size=dim)
        return np.concatenate((realpartlambda, imagpartlambda, coefficients))

    @classmethod
    def function(cls, param, t):
        """positive sum of exponential functions"""
        dim = int(len(param) / 3)
        exponents = param[:dim] + 1j * param[1 * dim:2 * dim]
        coeffs = param[2 * dim:] ** 2

        coeffsv, tv = np.meshgrid(coeffs, t)
        exponentsv, tv = np.meshgrid(exponents, t)
        return np.sum(coeffsv * np.exp(-exponentsv * tv), axis=1)


def ohm(t):
    """Ohm autocorrelation function"""
    s = 1
    return 1 / ((1 + t * 1j) ** (s + 1))


def generate_t_ohmic(s, T, N, r_c, frac):
    """Generate time points distributed like 1/(t-t_0) such that a fraction frac of points is less than the time t_c
    where |α(t_c)|/|α(0)| = r_c, where α is the (sub)ohmic autocorrelation function with parameter s"""
    t_c = np.sqrt(r_c ** (-2 / s + 1) - 1)
    c = (1 / t_c - frac / T) / (frac - 1)
    b = (frac * np.log(T) - np.log(t_c)) / (frac - 1)
    t_0 = np.exp(b) / (1 + c * np.exp(b))
    a = np.log((T + t_0) / t_0)
    u = np.linspace(0, 1, N)
    t = t_0 * (np.exp(a * u) - 1)
    return t


TARGET_FUNS = {
    'ohm': ohm
}

FIT_FUNS = {
    'general-ou': FitOU,
    'exp': FitExp,
    'exp-pos': FitExpPos
}
